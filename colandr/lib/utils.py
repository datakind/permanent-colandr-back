import io
import logging

import dedupe
from sqlalchemy.sql import text

from colandr import create_app, db


def execute_raw_sql_query(query, bindings=None, no_logging=True):
    """
    see: http://docs.sqlalchemy.org/en/latest/core/tutorial.html#specifying-bound-parameter-behaviors
    and: http://docs.sqlalchemy.org/en/latest/core/tutorial.html#using-textual-sql
    """
    bindings = bindings or {}
    if no_logging is True:  # this doesn't appear to work
        logging.getLogger('sqlalchemy.engine').setLevel(logging.CRITICAL)
    app = create_app('default')
    with app.app_context():
        conn = db.engine.connect()
        results = conn.execute(text(query), **bindings)
        for result in results:
            yield result
        results.close()


def load_dedupe_model(settings_path, num_cores=2):
    """
    Get a trained dedupe model, instantiated from settings saved to disk.

    Args:
        settings_path (str): path to file on disk where settings data is saved;
            settings files are typically generated by saving the settings
            learned from ActiveMatching
        num_cores (int): number of processes that deduper will use if able

    Returns:
        :class:``dedupe.StaticDedupe``
    """
    with io.open(settings_path, mode='rb') as f:
        deduper = dedupe.StaticDedupe(f, num_cores=num_cores)
    return deduper


def make_record_immutable(record):
    """
    Convert in-place the mutable components of ``record`` (dict) into their
    immutable analogues. (``dedupe`` only works with immutable records.)
    """
    for key, val in record.items():
        if isinstance(val, list):
            record[key] = tuple(val)
        elif isinstance(val, dict):
            record[key] = dedupe.frozendict(val)
        elif isinstance(val, set):
            record[key] = frozenset(val)
    return record
